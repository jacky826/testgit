/*
 * main.c
 *
 * ============================================================================
 * Copyright (c) Texas Instruments Inc 2009
 *
 * Use of this software is controlled by the terms and conditions found in the
 * license agreement under which this software has been supplied or provided.
 * ============================================================================
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <getopt.h>
#include <strings.h>
#include <pthread.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <signal.h>

#include <xdc/std.h>

#include <ti/sdo/ce/CERuntime.h>
#include <ti/sdo/ce/Engine.h>

#include <ti/sdo/dmai/Dmai.h>
#include <ti/sdo/dmai/Fifo.h>
#include <ti/sdo/dmai/Pause.h>
#include <ti/sdo/dmai/BufferGfx.h>
#include <ti/sdo/dmai/Rendezvous.h>
#include <ti/sdo/fc/rman/rman.h>

#include <ti/sdo/dmai/Buffer.h>
#include <ti/sdo/dmai/Display.h>

#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <sys/mman.h>

#include "pvr_platform.h"
#include "pvr_watchdog.h"
#include "pvr_debug.h"
#include <GUI.H>
#include "appl/include/Task_UI/task_ui_var.h"
#include "appl/include/UI_Message.h"
#include "appl/include/timestamp_autogenerated.h"

//! [0]
// 版本字符串，在编译时由Makefile中定义的变量生成“timestamp_autogenerated.h”头文件，并将宏定义更新
const char version_string[] = PVR_DATE"--"PVR_TIME;
//! [0]

//! 以下内容为编解码部分初始化相关
//! [1]

#define MIN_TRANSPARENCY        0
#define MAX_TRANSPARENCY        0x77
#define NORMAL_TRANSPARENCY     0x55

//#define DISABLE_OSD

typedef struct UI_Object {
    Display_Handle      hOsd;
    Display_Handle      hAttr;
    UInt8               transparency;
    Bool                visible;
    Int                 osd;
    VideoStd_Type       videoStd;
} UI_Object;
typedef struct UI_Object *UI_Handle;

typedef struct UI_Attrs {
    Int             osd;
    VideoStd_Type   videoStd;
} UI_Attrs;

static Int numBufs;

void *ucgui_fb_addr=NULL;
int ucgui_x_res;
int ucgui_y_res;

UI_Handle               hUI                 = NULL;
Engine_Handle        hEngine		=NULL;

/******************************************************************************
 * setOsdTransparency
 ******************************************************************************/
static Int setOsdTransparency(UI_Handle hUI, Char trans)
{
    char flag = 0;
    Buffer_Handle hBuf;
    BufferGfx_Dimensions dim;	

    if ((flag = Display_get(hUI->hAttr, &hBuf)) < 0) {
        LOGE("Error code1 = %d, Failed to get attribute window buffer\n", flag);
		request2reboot();
        return -1;
    }
    BufferGfx_getDimensions(hBuf, &dim);
    memset(Buffer_getUserPtr(hBuf), trans, Buffer_getSize(hBuf));
// LOGT("%s :attr plane: %d-%d buffersize = 0x%x trans = 0x%x\r\n",__func__,(int)dim.width,(int)dim.height,Buffer_getSize(hBuf),(int)trans);
    if ((flag = Display_put(hUI->hAttr, hBuf)) < 0) {
        LOGE("Error code2 = %d, Failed to put display buffer\n", flag);
		request2reboot();
        return -1;
    }

    return 1;
}
void enable_osd_dis(OSD_ALPHA_RECT *pRect, DWORD nRect)
{
    char flag = 0;
    if(hUI!=NULL) {
        Buffer_Handle hBuf,hBuf_osd;
        BufferGfx_Dimensions dim,dim_osd;	
        int m,n;		
        char *ptr,*ptr_osd,*ptr_gui;		

        if ((flag = Display_get(hUI->hAttr, &hBuf)) < 0) {
            LOGE("Error code3 = %d, Failed to get attribute window buffer\n", flag);
			request2reboot();
            return;
        }

        if ((flag = Display_get(hUI->hOsd, &hBuf_osd)) < 0) {
            LOGE("Error Code4 = %d, Failed to get osd window buffer\n", flag);
			request2reboot();
            goto out1;
        }
        BufferGfx_getDimensions(hBuf_osd, &dim_osd);

        BufferGfx_getDimensions(hBuf, &dim);

        memset(Buffer_getUserPtr(hBuf), MIN_TRANSPARENCY, Buffer_getSize(hBuf));		
        for(n=0;n<nRect;n++) {
            ptr = 	Buffer_getUserPtr(hBuf);
            ptr += (dim.width/2)*pRect[n].Top;
            ptr +=( pRect[n].Left/2);

            ptr_osd= 	Buffer_getUserPtr(hBuf_osd);
            ptr_osd+= (dim_osd.width<<1)*pRect[n].Top;
            ptr_osd+=( pRect[n].Left<<1);
			
#if 0
            ptr_gui= 	ucgui_fb_addr;
            ptr_gui+= (ucgui_x_res<<1)*pRect[n].Top;
            ptr_gui+=( pRect[n].Left<<1);			
#endif
            for(m=0;m<pRect[n].Height;m++) {
                memset(ptr, hUI->transparency, pRect[n].Width/2);
                ptr += dim.width/2;				
#if 0 //use whole restrict memory copy instead of region copy
                memcpy(ptr_osd,ptr_gui , pRect[n].Width<<1);
                ptr_osd+= (dim_osd.width<<1);				
                ptr_gui += (ucgui_x_res<<1);								
#endif
            }				
            LOGT("%s:n=%d rect@(%d %d %d %d)\n",__func__,n,pRect[n].Top,pRect[n].Left,pRect[n].Height,pRect[n].Width);
        }				
//update the whole osd region 
        memcpy(Buffer_getUserPtr(hBuf_osd),ucgui_fb_addr,dim_osd.width*dim_osd.height*2);


        if ((flag = Display_put(hUI->hOsd, hBuf_osd)) < 0) {
            LOGE("Error code5 = %d, Failed to put osd display buffer\n", flag);
			request2reboot();
        }       

out1:		
        if ((flag = Display_put(hUI->hAttr, hBuf)) < 0) {
            LOGE("Error code6 = %d, Failed to put attribute display buffer\n", flag);
			request2reboot();
            return;
        }
    }			
}
void disable_osd_dis(void)
{
    FUNC_ENTER
    if(hUI!=NULL)
        setOsdTransparency(hUI,MIN_TRANSPARENCY);
}


/******************************************************************************
 * drawDynamicData
 ******************************************************************************/
static Void drawDynamicData(UI_Handle hUI)
{
	static int x=0,y=0;

	GUI_SetDrawMode(LCD_DRAWMODE_XOR);
	GUI_SetColor(0xffff);
	GUI_FillRect(x,y,x+100,y+100);
	x+=10;

	if((x+10)>=ucgui_x_res) {
		x=0;
		y+=10;
	}
	if((y+=10)>=ucgui_y_res) {
		y=0;
	}	
}

/******************************************************************************
 * clear the OSD screen
 ******************************************************************************/
Int clearOSD(UI_Handle hUI)
{
    Buffer_Handle hDispBuf;
    BufferGfx_Dimensions dim;
    Int BufIdx;

    for(BufIdx = 0; BufIdx<numBufs; BufIdx++)
    {
        if (Display_get(hUI->hOsd, &hDispBuf) < 0) {
            LOGE("Failed to get display buffer\n");
			request2reboot();
            return FAILURE;
        }
        BufferGfx_getDimensions(hDispBuf, &dim);

        if (Display_put(hUI->hOsd, hDispBuf) < 0) {
            LOGE("Failed to put display buffer\n");
			request2reboot();
            return FAILURE;
        }
    }
    return SUCCESS;
}

/******************************************************************************
 * cleanupUI
 ******************************************************************************/
static Int cleanupUI(UI_Handle hUI)
{
    Int ret=0;
    
    clearOSD(hUI);
     
    if (hUI->hOsd) {
        ret = Display_delete(hUI->hOsd);
        hUI->hOsd = NULL;		
    }
    if (hUI->hAttr) {
        ret = Display_delete(hUI->hAttr);
        hUI->hAttr = NULL;
    }

    free(hUI);

    return ret;
}

const Display_Attrs Display_Attrs_efDM365_ATTR_DEFAULT = {
    2,
    Display_Std_FBDEV,
    VideoStd_768P_60,
    Display_Output_EFLAGLCD,
    "/dev/fb2",
    0,
    ColorSpace_RGB565
    -1,
    -1,
    FALSE,
    0,
    0,
    FALSE    
};

const Display_Attrs Display_Attrs_efDM365_OSD_DEFAULT = {
    2,
    Display_Std_FBDEV,
    VideoStd_768P_60,
    Display_Output_EFLAGLCD,
    "/dev/fb0",
    0,
    ColorSpace_RGB565
    -1,
    -1,
    FALSE,
    0,
    0,
    FALSE    
};

/******************************************************************************
 * UI_create
 ******************************************************************************/
UI_Handle UI_create(UI_Attrs *attrs)
{
    Display_Attrs          oAttrs      = Display_Attrs_efDM365_OSD_DEFAULT;
    Display_Attrs          aAttrs      = Display_Attrs_efDM365_ATTR_DEFAULT;
    UI_Handle              hUI;
	
    hUI = malloc(sizeof(UI_Object));

    if (hUI == NULL) {
        LOGE("Failed to allocate space for UI Object\n");
		request2reboot();
        return NULL;
    }

    memset(hUI,0,sizeof(UI_Object));//SACH:W10892
    hUI->osd = attrs->osd;
    hUI->videoStd = attrs->videoStd;
	
    hUI->hAttr = Display_create(NULL, &aAttrs);

    if (hUI->hAttr == NULL) {
        LOGE("Failed to create attribute window device\n");
        cleanupUI(hUI);
		request2reboot();
        return NULL;
    }

    if (attrs->osd) {
#if 1
        numBufs = oAttrs.numBufs;
#else
        oAttrs.numBufs = numBufs = 1;
#endif
        hUI->hOsd = Display_create(NULL, &oAttrs);
        if (hUI->hOsd == NULL) {
            LOGE("Failed to create osd window device\n");
            cleanupUI(hUI);
			request2reboot();
            return NULL;
        }

        hUI->transparency = NORMAL_TRANSPARENCY;
        setOsdTransparency(hUI, hUI->transparency);
    }else {
        setOsdTransparency(hUI, 0);
    }

    return hUI;
}


/******************************************************************************
 * UI_init
 ******************************************************************************/
Int UI_init(UI_Handle hUI)
{
    BufferGfx_Dimensions dim;
    Buffer_Handle hBuf;
    Int bufIdx;

    if (hUI->osd) {
        for (bufIdx = 0; bufIdx < BufTab_getNumBufs(Display_getBufTab(hUI->hOsd)); bufIdx++) {

            /* Get a buffer from the display device driver */
            if (Display_get(hUI->hOsd, &hBuf) < 0) {
                LOGE("Failed to get display buffer\n");
				request2reboot();
                return FAILURE;
            }
            BufferGfx_getDimensions(hBuf, &dim);
            ucgui_x_res = dim.width;
            ucgui_y_res=dim.height;
			
#if 0
            ucgui_fb_addr = Buffer_getUserPtr(hBuf);
            LOGT("OSD plane: fb_addr to 0x%x X=%d Y=%d \n",ucgui_fb_addr,(int)dim.width,(int)dim.height);
#endif			
		 
            /* Give a filled buffer back to the display device driver */
            if (Display_put(hUI->hOsd, hBuf) < 0) {
                LOGE("Failed to put display buffer\n");
				request2reboot();
                return FAILURE;
            }		 
            		
        }
#if 1
        ucgui_fb_addr = malloc(ucgui_x_res*ucgui_y_res*2);
        if(ucgui_fb_addr == NULL) {
            LOGE("alloc buffer for ucgui failed\n");
			request2reboot();
        }
#endif
	if(ucgui_fb_addr!=NULL) {
		GUI_Init();
	}
	LOGT("ui_init  OK\n");
    }
    return SUCCESS;
}


/******************************************************************************
 * uiSetup
 ******************************************************************************/
static UI_Handle uiSetup()
{
    UI_Attrs  uiAttrs;
    UI_Handle hUI;

    /* Create the user interface */
    uiAttrs.osd = 1;
    uiAttrs.videoStd = VideoStd_768P_60;

    hUI = UI_create(&uiAttrs);

    if (hUI == NULL) {
        LOGE("Failed to create UI\n");
		request2reboot();
        return NULL;
    }

    /* Initialize the user interface */
    UI_init(hUI);
    return hUI;
}
/******************************************************************************
 * UI_delete
 ******************************************************************************/
Int UI_delete(UI_Handle hUI)
{
    int ret =Dmai_EFAIL;
    if (hUI) {
        ret = cleanupUI(hUI);
    }
    if(ucgui_fb_addr!=NULL) {
        free(ucgui_fb_addr);
        ucgui_fb_addr = NULL;
    }	
    return ret; 
}

//! [1]

//! 主流程
//! [2]
//extern void Task_UI(void * pdata);
//extern int Initial_map_fpga(void);
//extern void Deinital_map_fpga(void);

// 返回码全局变量定义
int exit_code=EXIT_CODE_NORMAL;
/******************************************************************************
 * main
 ******************************************************************************/
Int main(Int argc, Char *argv[])
{
    // 初始化编解码库相关内容之前,初始化调试日志相关内容,FPGA,看门狗
    // [0]
    // 初始化调试信息输出，使用syslog的方法记录日志时，需要进行初始化
    // 目前日志记录不使用syslog的方法,因此该步不做操作
    DEBUG_INIT;

    // 修改系统配置参数，以解决在128M记录板上，数据刷新到cf卡占用内存较多的问题
    // 补充：在后续测试中，未发现有明显改善或其他区别。在将记录板改为256M DDR之后，内存已够用。
    LOGT("edit sys/vm/ options\r\n");
    system("sync");
    system("sync");
    system("echo 5 > /proc/sys/vm/dirty_ratio");
    system("echo 100 > /proc/sys/vm/dirty_writeback_centisecs");
    system("echo 50 > /proc/sys/vm/dirty_expire_centisecs");
    system("sync");
    system("sync");
    usleep(500000);

    // 初始化log记录功能相关内容，如果启用，将开机时的内核启动信息保存到临时文件中
    if(is_log_en() == 0)
    {
        LOGT("log not enabled\n");
    }
    else
    {
        LOGT("log enabled\n");
    }
    //将stderr和stdout信息重新定向到/tmp/pvr_startup.log文件中
    redirect_log(LOG_PATH_TMP,LOG_FILE_STARTUP);

    // 初始化fpga寄存器控制
	Initial_map_fpga();

    // 启动硬件看门狗线程，在看门狗线程中进行喂狗，在主线程有阻塞操作时（例如加载、卸载U盘时），防止触发硬件看门狗
    OPEN_WATCHDOG();

    // 为系统初始化预留15s（30*500ms）时间，这期间内由看门狗线程喂狗
	START_WATCHDOG_TIMER_SIG(30);

    LOGT("dm365 pvr started compile time %s.\n",version_string);

#if DEBUG_V2_1
	LOGT("DEBUG_V2_1 defined\r\n");
#endif
    // [0]

    // 编解码库相关初始化
    // [1]
    Init_UI_Message();

    /* Set the priority of this whole process to max (requires root) */
// 0905 test    setpriority(PRIO_PROCESS, 0, -20);

    /* Initialize Codec Engine runtime */
    CERuntime_init();

    /* Initialize Davinci Multimedia Application Interface */
    Dmai_init();

    //Dmai_setLogLevel(Dmai_LogLevel_ErrorsWarnings);
#ifndef DISABLE_OSD	
    /* Set up the user interface */

    hUI = uiSetup();

    if (hUI == NULL) {
        LOGE("uiSetup failed");
		request2reboot();
        return -1;
    }
#else
    ucgui_x_res = 1024;
    ucgui_y_res=768;
			
    ucgui_fb_addr = malloc(ucgui_x_res*ucgui_y_res*2);
    if(ucgui_fb_addr == NULL) {
        LOGE("alloc buffer for ucgui failed\n");
    }
    if(ucgui_fb_addr!=NULL) {
	    GUI_Init();
    }
#endif
	
    /* Open the codec engine */
    if(hEngine  == NULL)	
        hEngine = Engine_open("pvrcodec", NULL, NULL);
//	Initial_map_fpga();
    // [1]

	
    // 进入系统主流程
    // [2]
    Task_UI(NULL);

    if (hEngine) {
        Engine_close(hEngine);
        hEngine = NULL;
    }
    // [2]
	
    // 系统运行结束,反初始化并退出
    // [3]
    if (hUI) {
        UI_delete(hUI);
    }

    Deinit_UI_Message();
    DEBUG_DEINIT;
	Deinital_map_fpga();	

	LOGT("exit_code: %d\r\n",exit_code);
    exit(exit_code);
    // [3]
}

//! [2]

